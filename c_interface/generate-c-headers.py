#!/usr/bin/env python3
import argparse
from pathlib import Path

from numpy.f2py import crackfortran

HEADER = """// This file was automatically generated by generate-c-headers.py
# pragma once
#include <slicot/slicot_mangle.h>

#ifdef __cplusplus
extern "C" {
#endif

"""

FOOTER = """
#ifdef __cplusplus
}
#endif
"""


F2C_TYPE_MAP = {
    'integer': 'int',
    'character': 'char',
    'double precision': 'double',
    'logical': 'int',  # numpy appears to (maybe) use size_t
    'complex': 'double _Complex',
}


def category_glob(category):
    return f"{category[0].upper()}*.f"


def make_const(in_type):
    return f"const {in_type} const*"


def arg_to_c_arg(name, arg_spec):
    c_type = F2C_TYPE_MAP[arg_spec['typespec']]
    intent = arg_spec.get('intent', None)
    if intent is None:
        c_type += "*"
    elif intent == "input":
        c_type = make_const(c_type)
        assert None
    else:
        raise ValueError("Unknown intent: %s" % intent)

    notes = f'{name}: '
    for note in ['=', 'check', 'depend', 'attrspec']:
        if note in arg_spec:
            notes += f'{note}: {arg_spec[note]}, '

    return f"{c_type} {name}", notes.strip()


def parse_one_method(method_spec):
    name = method_spec['name']
    # if 'user__routines' in name:
    #     import ipdb; ipdb.set_trace()
    if '_' in name:
        raise KeyError("Unknown name")
    result = 'void'
    if 'result' in method_spec:
        result = F2C_TYPE_MAP[method_spec['result']]

    signature = f"{result} {name}("
    doc_comment = "///"
    docstring = doc_comment
    num_args = len(method_spec['args'])

    for idx in range(num_args):
        arg_name = method_spec['args'][idx]
        c_arg, doc = arg_to_c_arg(arg_name, method_spec['vars'][arg_name])
        suffix = ", "
        doc_suffix = ""
        if idx == num_args-1:
            suffix = ");"
            doc_suffix = f"\n{doc_comment}"
        signature += c_arg + suffix
        docstring += "\n" + f"{doc_comment} {doc}{doc_suffix}"

    return signature, docstring


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog=__file__,
        description="Generate C header files from fortran code with f2py.",
    )
    parser.add_argument(
        "--category",
        choices=[
            "analysis",
            "benchmarks",
            "data_analysis",
            "control_adaptive",
            "filtering",
            "identification",
            "math",
            "nonlinear_systems",
            "transformations",
            "synthesis",
            "utilities"
        ],
        required=True,
        help="Which set of fortran files to look at. The resulting header file"
        "will be <category>.h"
    )
    parser.add_argument(
        "--output-dir",
        required=True,
        type=Path,
        help="Write header files to this directory.",
    )
    args = parser.parse_args()
    category = args.category
    output_dir = args.output_dir
    output_dir.mkdir(parents=True, exist_ok=True)

    # f = "slycot/src/SLICOT-Reference/src/AB01MD.f"
    root = Path(__file__).resolve().parent.parent / "src"

    files = root.glob(category_glob(category))
    files = [str(f) for f in files]

    output_file = output_dir / (category + ".h")
    print("Output file is ", output_file)
    print("category is ", category)

    all_methods = crackfortran.crackfortran(files)
    with output_file.open("w") as fid:
        fid.write(HEADER)
        fid.write("\n")

    for method_spec in all_methods:
        name = method_spec.get('name', 'unknown')
        try:
            signature, docstring = parse_one_method(method_spec)
        except KeyError:
            print(f"failed to parse {name}")
            continue


        with output_file.open("a+") as fid:
            fid.write(docstring)
            fid.write("\n")
            name_l = name.lower()
            name_u = name.upper()
            fid.write(f"#define {name} SLICOT_C_GLOBAL({name_l}, {name_u})\n")
            fid.write(signature)
            fid.write("\n\n")


    with output_file.open("a+") as fid:
        fid.write(FOOTER)
